### Цель и идея ООП
ООП позволяет разложить проблему на связанные между собой задачи. Каждая задача становится самостоятельным объектом, содержащим свои собственные коды и данные, которые относятся к этому объекту. В этом случае исходная задача в целом упрощается, и программист получает возможность оперировать с большими по объему программами.
Тут отражается известный подход к решению сложных задач, когда мы разбиваем задачу на подзадачи и решаем эти подзадачи по отдельности. Подобный подход значительно упрощает разработку и отладку программ.

### Типы полиморфизмов и их отличия
[Бьёрн Страуструп определил полиморфизм как «один интерфейс — много реализаций»](https://www.stroustrup.com/glossary.html#Gpolymorphism)
#####
[Википедия](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%BB%D0%B8%D0%BC%D0%BE%D1%80%D1%84%D0%B8%D0%B7%D0%BC_(%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0)) определяет это как способность методов обрабатывать разные типы данных
#####
[Из книги "Приемы объектно-ориентированного проектирования"](http://www.sugardas.lt/~p2d/books/Priemioop.pdf)
#####
Когда объекту посылается запрос, то операция, которую он будет выполнять, зависит как от запроса, так и от объекта-адресата.
Разные объекты, поддерживающие одинаковые интерфейсы, могут выполнять в ответ на такие запросы разные операции.
Ассоциация запроса с объектом и одной из его операций во время выполнения называется *динамическим связыванием*.

Динамическое связывание означает, что отправка некоторого запроса не определяет никакой конкретной реализации до момента выполнения.
Следовательно, допустимо написать программу, которая ожидает объект с конкретным интерфейсом, точно зная, что любой объект
с подходящим интерфейсом точно сможет принять этот запрос. Более того, динамическое связывание позволяет во время выполнения
подставить вместо одного объекта другой, если он имеет точно такой же интерфейс. Такая взаимозаменяемость называется ***полиморфизмом***.
###
Другими словами, **полиморфизм** - это возможность динамической подстановки (подмены) объекта во время выполнения программы.
#####
[Выделяют несколько разновидностей полиморфизма.](https://en.wikipedia.org/wiki/Polymorphism_(computer_science)) Однако принято считать наиболее распространенными следующие три:
- **ad-hoc полиморфизм** (полиморфизм по запросу: *приведение данных* - когда данные уже приведены к тому типу данных, с которыми работает метод; и *перегрузка метода* - когда методы существуют в нескольких вариантах, с одинаковыми названиями, но разными параметрами)
- **параметрический полиморфизм** (может принимать параметры разных классов, например, параметром является базовый класс для некой иерархии объектов)
- **полиморфизм подтипов** (возможность объектов с одинаковой спецификацией иметь различную реализацию)

### Типы полиморфизмов в PHP и их реализация
В PHP реализован полиморфизм подтипов.
######
Важно отметить, что если метод в дочернем классе не был переопределен, то при обращении к нему будет вызван метод родительского класса.
Также следует понимать, что даже если метод был переопределен в дочернем классе, мы можем обратиться к этому же методу родителя.
######
Часто с полиморфизмом подтипов отождествляют и наследование:
- Концептуально, полиморфизм подтипов устанавливает отношение: «является», — тем самым имитируя семантическое отношение наследования;
- В свою очередь наследование в большей степени относится к повторному использованию кода, то есть определяет синтаксическое отношение.

Несмотря на приведённое выше замечание, наследование является широко используемым механизмом установки отношения «является».
Некоторые языки программирования согласуют наследование и полиморфизм подтипов (в основном, это относится к языкам со статической типизацией: C++, C#, Java и Scala) — в то время как другие разделяют вышеописанные концепции.

Наследование, — даже в языках программирования, которые поддерживают применение наследования как механизма, обеспечивающего полиморфизм подтипов,
— не гарантирует поведенческий полиморфизм подтипов («Принцип подстановки» Барбары Лисков).
### Преимущества и недостатки полиморфизма
"+"
- Позволяет клиенту не делать предположений об объектах, кроме того, что они поддерживают определенный интерфейс
  (обработка различных данных не различая вида объекта)
- Позволяет изменять поведение во время исполнения
- Позволяет создать базу, каркас для будущих приложений
######
"-"
- При изменении определенного в базовом классе метода, который не имеет своей собственной реализации в потомке,
  может возникнуть непредсказуемое поведение программы.
- Может уменьшить читаемость кода. Поскольку полиморфизм идёт в ногу с наследованием и сам полиморфный метод,
  объявленный в базовом и/или родительском классе может иметь разную реализацию — определение и ориентирование среди
  всей иерархии классов становится затруднительным, особенно когда требуется определить реализацию в определенный
  момент времени, что в свою очередь, в некоторой степени, может увеличить время работы разработчика.

### Преимущества и недостатки наследования
"+"
- П
######
"-"
- П
### Как заменить наследование

### SOLID

### GRASP

### Агрегация VS композиция

### Паттерны

### Singleton - это антипаттерн. Причина. Как решить на примере: “Singleton реализует соединение с прод БД. Как произвести тестирование с тестовой БД?”

### По ТЗ (гит):
- review
- какие паттерны используются
- преимущества и недостатки switch case, чем заменить
- нужно ли менять try catch и по какой причине

### Задача

Есть файл на неопределенное количество строк. В каждой строке информации на 10 - 1024 кБ.
Необходимо реализовать функционал для переноса уникальных строк в БД.
Со временем количество файлов может увеличиться. Уникальность строк в рамках разных файлов не гарантируется (тоесть строка в одном файле может дублироваться и в другом файле)

Описать алгоритм и ключевые моменты реализации функционала.
