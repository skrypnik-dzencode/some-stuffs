### Цель и идея ООП

ООП позволяет разложить проблему на связанные между собой задачи. Каждая задача становится самостоятельным объектом,
содержащим свои собственные коды и данные, которые относятся к этому объекту. В этом случае исходная задача в целом
упрощается, и программист получает возможность оперировать с большими по объему программами. Тут отражается известный
подход к решению сложных задач, когда мы разбиваем задачу на подзадачи и решаем эти подзадачи по отдельности. Подобный
подход значительно упрощает разработку и отладку программ.

<sub><sup>(По словам Алана Кея, ООП - это совокупность объектов для обмена сообщениями) Тут также можно вспомнить о
примере с просьбой "подать соль": определить все инструкции, результатом выполнения которых соль будет получена, или
обратиться с просьбой подачи соли к объекту, который сам определяет все инструкции и возвращает "соль"</sup></sub>

### Типы полиморфизмов и их отличия

Бьёрн Страуструп [определил](https://www.stroustrup.com/glossary.html#Gpolymorphism) полиморфизм как «один интерфейс —
много реализаций»

#####

[Википедия](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%BB%D0%B8%D0%BC%D0%BE%D1%80%D1%84%D0%B8%D0%B7%D0%BC_(%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0))
определяет это как способность методов обрабатывать разные типы данных

#####

[Из книги "Приемы объектно-ориентированного проектирования"](http://www.sugardas.lt/~p2d/books/Priemioop.pdf) <br>
Когда объекту посылается запрос, то операция, которую он будет выполнять, зависит как от запроса, так и от
объекта-адресата. Разные объекты, поддерживающие одинаковые интерфейсы, могут выполнять в ответ на такие запросы разные
операции. Ассоциация запроса с объектом и одной из его операций во время выполнения называется *динамическим
связыванием*.

Динамическое связывание означает, что отправка некоторого запроса не определяет никакой конкретной реализации до момента
выполнения. Следовательно, допустимо написать программу, которая ожидает объект с конкретным интерфейсом, точно зная,
что любой объект с подходящим интерфейсом точно сможет принять этот запрос. Более того, динамическое связывание
позволяет во время выполнения подставить вместо одного объекта другой, если он имеет точно такой же интерфейс. Такая
взаимозаменяемость называется ***полиморфизмом***.

###

Другими словами, **полиморфизм** - это возможность динамической подстановки (подмены) объекта во время выполнения
программы.

#####

[Выделяют несколько разновидностей полиморфизма.](https://en.wikipedia.org/wiki/Polymorphism_(computer_science))
Однако принято считать наиболее распространенными следующие три:

- **ad-hoc полиморфизм** (полиморфизм по запросу: *приведение данных* - когда данные уже приведены к тому типу данных, с
  которыми работает метод; и *перегрузка метода* - когда методы существуют в нескольких вариантах, с одинаковыми
  названиями, но разными параметрами)
- **параметрический полиморфизм** (может принимать параметры разных классов и обрабатывать значения разных типов
  одинаково, то есть, физически исполнять один и тот же код дла разных типов)
- **полиморфизм подтипов** (возможность объектов с одинаковой спецификацией иметь различную реализацию)

### Типы полиморфизмов в PHP и их реализация

В PHP реализован полиморфизм подтипов.

######

Важно отметить, что если метод в дочернем классе не был переопределен, то при обращении к нему будет вызван метод
родительского класса. Также следует понимать, что даже если метод был переопределен в дочернем классе, мы можем
обратиться к этому же методу родителя.

######

Часто с полиморфизмом подтипов отождествляют и наследование:

- Концептуально, полиморфизм подтипов устанавливает отношение: «является», — тем самым имитируя семантическое отношение
  наследования;
- В свою очередь наследование в большей степени относится к повторному использованию кода, то есть определяет
  синтаксическое отношение.

Несмотря на приведённое выше замечание, наследование является широко используемым механизмом установки отношения
«является». Некоторые языки программирования согласуют наследование и полиморфизм подтипов
(в основном, это относится к языкам со статической типизацией: C++, C#, Java и Scala) — в то время как другие разделяют
вышеописанные концепции.

Наследование, даже в языках программирования, которые поддерживают применение наследования как механизма,
обеспечивающего полиморфизм подтипов, — не гарантирует поведенческий полиморфизм подтипов («Принцип подстановки» Барбары
Лыськов).

### Преимущества и недостатки полиморфизма

"+"

- Позволяет клиенту не делать предположений об объектах, кроме того, что они поддерживают определенный интерфейс
  (обработка различных данных не различая вида объекта)
- Позволяет изменять поведение во время исполнения
- Позволяет создать базу, каркас для будущих приложений

######

"-"

- При изменении определенного в базовом классе метода, который не имеет своей собственной реализации в потомке, может
  возникнуть непредсказуемое поведение программы.
- Может уменьшить читаемость кода. Поскольку полиморфизм идёт в ногу с наследованием и сам полиморфный метод,
  объявленный в базовом и/или родительском классе, может иметь разную реализацию — значит определение и ориентирование
  среди всей иерархии классов становится затруднительным, особенно когда требуется определить реализацию в определенный
  момент времени, что в свою очередь, в некоторой степени, может увеличить время работы разработчика.

Важно. По сути, это не "прямые" недостатки полиморфизма, а, своего рода, отражения (влияния) недостатков наследования.

### Преимущества и недостатки наследования

"+"

- Повторное использование кода (и производные: компоненты, программы, макеты/прототипы)
- Связанность объектов
- Согласованность интерфейсов
- Сокрытие данных
- Полиморфизм

######

"-"

- Связанность объектов
- Может уменьшить читаемость кода. Поскольку полиморфизм идёт в ногу с наследованием и сам полиморфный метод,
  объявленный в базовом и/или родительском классе, может иметь разную реализацию — значит определение и ориентирование
  среди всей иерархии классов становится затруднительным, особенно когда требуется определить реализацию в определенный
  момент времени, что в свою очередь, в некоторой степени, может увеличить время работы разработчика.
- Усложнение кода. Модификация родительского класса может повлиять на поведение классов потомков, и если поведение
  потомка логически не может быть согласованным в соответствии с новым методом, то приходиться либо менять структуру
  иерархии классов, либо нарушать принцип подстановки Барбары Лыськов.

### Как заменить наследование

[Композицией.](https://coderlessons.com/articles/programmirovanie/zamena-nasledovaniia-kompozitsiei)
Суть заключается в том, что создаётся отдельный класс, в котором новое поле (свойство) является объектом нужного класса
и определяется путем передачи данного класса в соответствующий метод извне.

По сути это также может быть и реализация паттерна Делегирование, что в свою очередь является своего рода реализацией
паттерна Стратегия.
[Подробнее](https://refactoring.guru/ru/replace-inheritance-with-delegation)

### SOLID

Как многие знают - это аббревиатура, состоящая из первых букв пяти базовых принципов ООП и дизайна, предложенных
Робертом Мартином (Uncle Bob)

|Letter|ABBR|Description|
|---|---|---|
|**S**|**SRP**|The Single Responsibility Principle (_Принцип единой ответственности_)|
|**O**|**OCP**|The Open Closed Principle (_Принцип открытости / закрытости_)|
|**L**|**LSP**|The Liskov Substitution Principle (_Принцип подстановки Барбары Лыськов_)|
|**I**|**ISP**|The Interface Segregation Principle (_Принцип разделения интерфейсов_)|
|**D**|**DIP**|The Dependency Inversion Principle (_Принцип инверсии зависимостей_)|

##### Single responsibility principle

Данный принцип говорит нам, что класс/модуль должен обладать единой ответственностью. Например, класс, отвечающий за
оформление заказа не должен дополнительно формировать 2 фала PDF (для покупателя и менеджера) и уж тем более отправлять
письма с этими файлами. <br>
Казалось бы просто, однако, как всегда, есть нюанс. Рассмотрим на примере. Мы пишем некий обработчик исключений
(ExceptionHandler), задача которого фиксировать исключения. Ответственность тут одна - фиксировать исключения, НО,
фиксировать их можно как в БД, так и в файл, так и по АПИ отправлять на внешний сервис - следовательно ответственностей
тут может быть несколько. <br>
Так соблюдён ли тут **SPR**? - как всегда, "дьявол кроется в деталях".
[Согласно](http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod)
все тому же Дяде Бобу, который определяет "_ответственность_" как "_причину для изменения_" **_принцип единой
ответственности_**
глаголит: **"класс должен иметь одну, и только одну причину для изменения"**. Итого, если причин для изменения класса
одна - поздравляю, значит принцип **SPR** соблюдён. Иначе - увы, нет.

##### Open closed principle

"Программные сущности должны быть открыты для расширения, но закрыты для модификации". На более простых словах это можно
описать так — все классы, функции и т.д. должны проектироваться так, чтобы для изменения их поведения, нам не нужно было
изменять их исходный код. Вернемся всё к тому же модулю ExceptionHandler. Наступает время протестировать наш модуль. С
БД и с файлами проблем нет, ибо мы полностью контролируем базу и файлы и перед выкатом на прод мы можем делать с ними
всё что хотим. Но когда речь идёт про передачу данный во внешний сервис - возникают сложности, ибо мы не хотим
использовать внешний ресурс. Как быть? - переписать класс, который отправляет данные - но ведь это модификация самого
класса. А значит и сам принцип **OCP** нарушен.

##### Liskov substitution principle

Наверное, наиболее непонятный принцип для новичка. Чего только стоит
материал [википедии](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF_%D0%BF%D0%BE%D0%B4%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B8_%D0%91%D0%B0%D1%80%D0%B1%D0%B0%D1%80%D1%8B_%D0%9B%D0%B8%D1%81%D0%BA%D0%BE%D0%B2) <br>
Сама Барбара кратко сформулировала его так: <br>
_Пусть **q(x)** является свойством, верным относительно объектов **x** некоторого типа **T**. Тогда **q(y)** также
должно быть верным для объектов **y** типа **S**, где **S** является подтипом типа **T**._ <br>
Идея Лыськов о **подтипе** даёт определение понятия **замещения** — если **S** является подтипом **T**, тогда объекты
типа **T** в программе могут быть замещены объектами типа **S** без каких-либо изменений желательных свойств этой
программы. <br>
Этот принцип является важнейшим критерием для оценки качества принимаемых решений при построении иерархий
наследования. <br>
Сформулировать его можно в виде простого правила: тип **S** будет подтипом **Т** тогда и только тогда, когда каждому
объекту **oS**
типа **S** соответствует некий объект **oT** типа **T** таким образом, что для всех программ **P**, реализованных в
терминах **T**, поведение **P** не будет меняться, если **oT** заменить на **oS**. <br>
Более простыми словами можно сказать, что поведение наследующих классов не должно противоречить поведению, заданному
базовым классом, то есть поведение наследующих классов должно быть ожидаемым для кода, использующего переменную базового
типа.

Пробуем разобраться на примерах. <br>
У нас есть программа, в рамках которой считается расстояние миграции птиц в течение года в зависимости от типа птицы. И
у нас есть некая структура семейства объектов птиц. Класс "Птица" - абстрактный класс с абстрактными
геттерами: `wingSpan()`, `yearMigrationLiveTime()`, `flySpeed()`; реализации потомков "Ворона", "Сойка"...<br>
Углубляясь, класс "водоплавающаяПтица", потомок класса "Птица" и реализация уже этого класса: "Чайка", "Утка", "Лебедь"
... <br>
Задача - определить наличие корреляции расстояния и размаха крыла. <br>
С объектами, наследуемыми от класса "Птица", в том числе и "водоплавающаяПтица" - вопросов не возникает. Но когда нам
необходимо поработать с объектами "Страус", "Пингвин" или "Киви" - возникают некие сложности. Ведь во время реализации
геттера `flySpeed`
мы либо должны бросить исключение, либо строку с текстом `"__CLASS__ can't fly"`, либо вернуть `NULL`. А наша программа
не умеет работать ни с исключениями, ни со строкой, ни с `null`. А даже если мы попробуем обойти это и вернуть `0` -
результат может оказаться не верным и/или непредсказуемым. <br>
И, как следствие, принцип **LSP** будет нарушен.

##### Interface segregation principle

##### Dependency inversion principle

### GRASP

**G**eneral **R**esponsibility **A**ssignment **S**oftware **P**atterns

Это паттерны проектирования, используемые в ООП для решения общих задач по назначению обязанностей классам и
объектам.</br>
Или проще - шаблоны распределения обязанностей.

Однако стоит понимать, что хоть в названии и встречается слово **Patterns** - это не значит что речь пойдёт целиком и
полностью о паттернах (шаблонах) проектирования, а больше о, своего рода, принципах распределения ответственности.</br>
В книге Крега Лармана «Применение UML и шаблонов проектирования» описано 9 таких _**принципов-шаблонов**_. Каждый
помогает решить некоторую проблему, возникающую как в объектно-ориентированном анализе, так и в практически любом
проекте по разработке программного обеспечения. Таким образом, шаблоны **G.R.A.S.P.** — хорошо документированные,
стандартизированные и проверенные временем принципы объектно-ориентированного анализа, а не попытка привнести что-то
принципиально новое.

###### Основные:

- **Information Expert** (Информационный эксперт)
- **Creator** (Создатель)
- **Controller** (Контроллер)
- **Low Coupling** (Низкая связанность)
- **High Cohesion** (Высокая сцепленность)

###### Дополнительные:

- **Pure Fabrication** (Чистое производство или Чистая выдумка)
- **Indirection** (Посредник)
- **Polymorphism** (Полиморфизм)
- **Protected Variations** (Сокрытие реализации)

#### Information Expert

Информационный эксперт. Как можно предположить из названия - это должен быть объект, который обладает нужной
информацией.</br>
Рассмотрим на примере Форума и получении информации о количестве комментариев к определенному посту и итоговом
количестве комментариев для конкретной категории.</br>
Допустим имеем такую структуру: `Forum->Category->Post->Comment`</br>
В нашем конкретном случае для определения информационного эксперта нам необходимо ответить на вопросы:

- Кто должен знать количество комментариев к посту?
- Кто должен знать количество комментариев всех постов категории?

Когда мы определяем все данные для страницы с постами темы (категории) форума, а именно список постов - то логично
использовать сущность категории и для определения количества постов данной категории. Этот же принцип мы можем
использовать и для получения количества комментариев к каждому такому посту. А это значит, что общее количество
комментов ко всем постам категории необходимо получить непосредственно благодаря объекту (классу) Category.</br>
Рассмотрим другой пример:</br>
Имеем систему классов: Customer (покупатель/клиент), Order (заказ), содержащий список OrderItemList (строчек заказа),
элементы которого в свою очередь содержат Product (товар) и его количество, а товар может содержать, например, цену,
название и т.д.</br>
Теперь нам необходимо просчитать сумму заказа. Возвращаясь к вопросам, описанным выше - кто как не клиент работает с
заказами? Следовательно, получить сумму товаров можно написав простой метод в клиентском коде (классе), работающим с
заказом, в котором циклом проходим по всем строчкам заказа и суммируем цену товаров.</br>
Казалось бы всё очевидно. Проанализируем кейс. Бизнес-логика для определения итоговой суммы заказа определена в
клиентском коде и может там же модифицироваться в будущем, допустим различными скидками, купонами, оптовыми ценами и
пр... Насколько разумно будет добавлять массу IF-ов в это метод, поддерживать его, при этом править непосредственно
клиентский клас. Появляется дополнительная зависимость класса Customer от других сущностей. А если нам потребуются эти
вычисления для в другом месте (склад, доставка, ежемесячные отчёты) ?</br>
Отвечая на эти вопросы приходим к выводу, что логичнее разместить метод определения стоимости непосредственно в классе,
отвечающем за сам заказ. Клиентский код теперь будет зависеть только на сущности Order и не будет иметь понятия о том,
как именно происходят вычисления.</br>
По итогу получаем, что тот, кто обладает максимальным количеством информации - и должен выступать в роли информационного
эксперта.</br>
Таким образом, мы соблюдаем базовый принцип распределённости ответственности: _**Ответственность должна быть назначена
тому, кто владеет максимумом необходимой информации для исполнения — информационному эксперту.**_</br>

#### Creator

Создатель. Так же как и с информационным экспертом, только по одному названию можно понять, что ответственность такого
объекта - создание новых объектов. Кто уже знаком с порождающими паттернами проектирования сразу вспоминает о
паттерне **абстрактная фабрика**. Однако, далеко не всегда можно применить данный паттерн для реализации нужного
функционала. Например, с тем же простым форумом. Нет необходимости писать абстрактную фабрику для создания комментариев,
однако создавать их всё же нужно. А следовательно и ответственность также должна быть. <br>
И так, пользователь на сайте решил оставить комментарий. Комментарий с одной стороны принадлежит определенному посту, а
с другой стороны - пользователю. Логично предположить, что раз эти действия принадлежат пользователю - то и создавать
комментарии должен тоже пользователь. Следовательно, пользователь и есть создатель. <br>
Однако, попробуем посмотреть на это с иной стороны, со стороны Крега Лармана. По аналогии с информационным экспертом для
определения роли создателя нам необходимо определить объект, который в наибольшем случае удовлетворяет следующим
условиям: <br>
**_объект А должен порождать объект Б, если:_**

- объект **А** содержит или агрегирует объекты **Б**
- объект **А** активно использует объекты **Б**
- объект **А** записывает объекты **Б**
- объект **А** обладает данными для инициализации объекта и передаёт их при создании **Б**

Возвращаясь к примеру с форумом и отвечая на эти вопросы - очевидно, что ответственностью создавать объекты комментария
необходимо наделить сущность `Post`.

#### Controller

Преимущественно, **контроллер** принято считать как раз таки тем контроллером, который известен в известной **MVC**
парадигме:
принять request клиента, передать данные request модели, получить ответ от модели и вернуть клиенту response.
Собственно, это объект, который призван решить вопрос разделения UI-интерфейс пользователя и его действий от
бизнес-логики приложения. Также немаловажным моментом является то, что объект **контроллер** не относится к
пользовательскому интерфейсу, который отвечает за получение или обработку системного события. <br>
Другими словами, контроллер отвечает за обработку входящих системных событий, делегируя обязанности для дальнейших
обработок этих событий компетентным системам (модули, классы, объекты). В общем случае контроллер может реализовать один
или несколько вариантов сценария использования. Например, для сценариев создания и удаления пользователя можно
использовать один контроллер, вместо двух отдельных. Важно понимать, что сам контроллер не должен содержать в себе
бизнес-логики. И не должен содержать большое количество методов: ТТУК (толстые тупые уродливые контроллеры) - признак
принятия некорректного архитектурного решения.

#### Low Coupling && High Cohesion

**Coupling** - это степень осведомленности систем (функций, объектов, модулей) друг о друге. <br>
**Cohesion** - это степень того, как методы одной системы (функции, объекта, модуля) сконцентрированы на главной цели
этой системы. <br>

![](https://raw.githubusercontent.com/skrypnik-dzencode/some-stuffs/master/images/oop/coupling_cohesion.png)

Рассмотрим более детально

###### Low Coupling

Данный принцип распределения обязанностей говорит о том, что необходимо делать части системы зависимыми от наименьшего
количества других частей. <br>
**Low Coupling** отвечает за то, что бы объекты в системе знали друг о друге как можно меньше. Ведь чем меньше объект
знает о других объектах, тем выше будет изолированность и тем меньше правок необходимо будет делать, если в системе
что-то поменяется. Если объекты в приложении сильно связанны, то любое изменение приводит к каскадному изменению во всех
связанных объектах. А это неудобно, ведь такой код становиться тяжело поддерживать. Следовательно, необходимо
проектировать систему так, чтобы код был слабо связан и зависел именно от абстракций, а не от реализаций. <br>
Например если некий класс Sale реализует интерфейс ISale и другие объекты зависят именно от ISale (от абстракции), то
когда мы захотим внести изменения касательно Sale – нам нужно будет всего лишь подменить реализацию. <br>
Принцип **Low Coupling** встречается и в **SOLID** в виде **Dependency Injection** (**DIP**). Его суть остается
прежней: <br>
**"Программируйте на основе абстракций, а не реализаций"**. <br>
Иными словами принцип **Low Coupling** позволяет избежать следующих проблем:

- При изменении в связанных классах, необходимо делать локальные изменения в данном классе
- Понимание каждого класса в отдельности усложняется и требует изучения всех связанных классов
- Повторное использование становится невозможным из-за того, что перетянув часть системы, необходимо тянуть почти всю
  систему.

###### High Cohesion

**High cohesion** принцип говорит нам о том, что элементы системы должны быть сфокусированы на решении проблемы самой
системы, и должны быть тесно связаны только друг с другом.

Возможно, этот может немного ввести в заблуждение, так как мы только что рассмотрели _Low coupling principe_, который
наоборот, говорит о необходимости слабой связанности.

> <sub>OFF TOPIC</sub>
>
> Дело в том, что проблематика может проявляться из-за терминологии, которая употребляется в разных источниках. К примеру, термин
> "система" может употребляться как ко всему приложению, так и к определенному пакету, модулю, да даже в рамках одного
> модуля, а в некоторых случаях еще и подмодуля, один объект также может быть своего рода системой. Еще немаловажный
> момент - это термин "класс". Казалось бы всё понятно, однако и тут могут ждать сюрпризы в понимании. Ведь мы говорим об
> ООП - Объектно Ориентированном Программировании, не о Классово Ориентированном Программировании, а именно об
> **ОБЪЕКТНО** ориентированном. А значит и контекст для термина "класс" в первую очередь следует попробовать воспринимать как для
> термина "объект". Ну и последнее по списку, но не по значению - это осознание того, что зачастую в разных источниках
> либо явно указан ЯП, либо не указан вообще. А это в свою очередь просто обязан наложить свою призму на восприятие
> информации: ведь если ЯП не указан - то контекст, скорее всего, следует воспринимать как некую абстракцию. А если указан
> и Вы его не знаете - то контекст для терминов "тип", "подтип", "объект" и пр... может не соответствовать тому
> определению, к которому "привыкли" Вы.

**Cohesion** - это мера того, насколько объекты одного модуля "тесно связаны" друг с другом в рамках данного модуля и не
связаны с объектами другого модуля, одно временно с этим они (объекты) также должны быть сфокусированными на выполнение
основной задачи самого модуля.

Ниже на диаграммах более наглядно показаны coupling && cohesion

![](https://raw.githubusercontent.com/skrypnik-dzencode/some-stuffs/oop-draft/images/oop/coupling_cohesion_2.png)

На рисунке 1 мы видим отличное соблюдение принципов low coupling и high cohesion: все 3 модуля ограничены и связаны
только между собой, а их элементы, в свою очередь, сцеплены только в рамках своих задач. <br>
На рисунке 2 мы уже не видим соблюдение оговариваемых принципов. Хоть очертания модулей и прослеживается - их элементы
разбросаны по системе в хаотичном порядке. <br>
Ну а рисунки 3 и 4... No comment.

Оглядываясь на оффтоп выше хотел бы обратить внимание, что **coupling && cohesion** могут быть подвержены не только
объекты в рамках модуля/под-модуля (для cohesion) и под-модули в рамках модуля (для coupling), но также и любые другие
сущности программы, приложения, комплекса сервисов и пр...

Следовательно, прежде чем приступить к написанию кода следует заранее определить какие цели будет преследовать каждый
комплексный компонент (сущность) и какие составные его части могут выступать в качестве атомарной составляющей
(естественно в контексте самого комплексного компонента). Таким образом это позволить получить базовые вводные для
соблюдения баланса coupling and cohesion.

### DI Container

### Агрегация VS композиция

### Паттерны

### Singleton - это антипаттерн. Причина. Как решить на примере: “Singleton реализует соединение с прод БД. Как произвести тестирование с тестовой БД?”

### По ТЗ (гит):

- review
- какие паттерны используются
- преимущества и недостатки switch case, чем заменить
- нужно ли менять try catch и по какой причине

### Задача

Есть файл на неопределенное количество строк. В каждой строке информации на 10 - 1024 кБ. Необходимо реализовать
функционал для переноса уникальных строк в БД. Со временем количество файлов может увеличиться. Уникальность строк в
рамках разных файлов не гарантируется (то есть строка в одном файле может дублироваться и в другом файле)

Описать алгоритм и ключевые моменты реализации функционала.
