### Цель и идея ООП
ООП позволяет разложить проблему на связанные между собой задачи. Каждая задача становится самостоятельным объектом,
содержащим свои собственные коды и данные, которые относятся к этому объекту. В этом случае исходная задача в целом упрощается,
и программист получает возможность оперировать с большими по объему программами.
Тут отражается известный подход к решению сложных задач, когда мы разбиваем задачу на подзадачи и решаем эти подзадачи по отдельности.
Подобный подход значительно упрощает разработку и отладку программ.

<sub><sup>(По словам Алана Кея, ООП - это совокупность объектов для обмена сообщениями) Тут также можно вспомнить о
примере с просьбой "подать соль": определить все инструкции, результатом выполнения которых соль будет получена;
или обратиться с просьбой подачи соли к объекту, который сам определеяет все инструкции и возвращает "соль"</sup></sub>

### Типы полиморфизмов и их отличия
Бьёрн Страуструп [определил](https://www.stroustrup.com/glossary.html#Gpolymorphism) полиморфизм как «один интерфейс — много реализаций»
#####
[Википедия](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%BB%D0%B8%D0%BC%D0%BE%D1%80%D1%84%D0%B8%D0%B7%D0%BC_(%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0))
определяет это как способность методов обрабатывать разные типы данных
#####
[Из книги "Приемы объектно-ориентированного проектирования"](http://www.sugardas.lt/~p2d/books/Priemioop.pdf) <br>
Когда объекту посылается запрос, то операция, которую он будет выполнять, зависит как от запроса, так и от объекта-адресата.
Разные объекты, поддерживающие одинаковые интерфейсы, могут выполнять в ответ на такие запросы разные операции.
Ассоциация запроса с объектом и одной из его операций во время выполнения называется *динамическим связыванием*.

Динамическое связывание означает, что отправка некоторого запроса не определяет никакой конкретной реализации до момента выполнения.
Следовательно, допустимо написать программу, которая ожидает объект с конкретным интерфейсом, точно зная, что любой объект
с подходящим интерфейсом точно сможет принять этот запрос. Более того, динамическое связывание позволяет во время выполнения
подставить вместо одного объекта другой, если он имеет точно такой же интерфейс. Такая взаимозаменяемость называется ***полиморфизмом***.
###
Другими словами, **полиморфизм** - это возможность динамической подстановки (подмены) объекта во время выполнения программы.
#####
[Выделяют несколько разновидностей полиморфизма.](https://en.wikipedia.org/wiki/Polymorphism_(computer_science))
Однако принято считать наиболее распространенными следующие три:
- **ad-hoc полиморфизм** (полиморфизм по запросу: *приведение данных* - когда данные уже приведены к тому типу данных, с которыми работает метод;
  и *перегрузка метода* - когда методы существуют в нескольких вариантах, с одинаковыми названиями, но разными параметрами)
- **параметрический полиморфизм** (может принимать параметры разных классов и обрабатывать значения разных типов одинаково, тоесть, физически исполнять один и тот же код дла разных типов)
- **полиморфизм подтипов** (возможность объектов с одинаковой спецификацией иметь различную реализацию)

### Типы полиморфизмов в PHP и их реализация
В PHP реализован полиморфизм подтипов.
######
Важно отметить, что если метод в дочернем классе не был переопределен, то при обращении к нему будет вызван метод родительского класса.
Также следует понимать, что даже если метод был переопределен в дочернем классе, мы можем обратиться к этому же методу родителя.
######
Часто с полиморфизмом подтипов отождествляют и наследование:
- Концептуально, полиморфизм подтипов устанавливает отношение: «является», — тем самым имитируя семантическое отношение наследования;
- В свою очередь наследование в большей степени относится к повторному использованию кода, то есть определяет синтаксическое отношение.

Несмотря на приведённое выше замечание, наследование является широко используемым механизмом установки отношения «является».
Некоторые языки программирования согласуют наследование и полиморфизм подтипов
(в основном, это относится к языкам со статической типизацией: C++, C#, Java и Scala) — в то время как другие разделяют вышеописанные концепции.

Наследование, даже в языках программирования, которые поддерживают применение наследования как механизма, обеспечивающего полиморфизм подтипов,
— не гарантирует поведенческий полиморфизм подтипов («Принцип подстановки» Барбары Лисков).
### Преимущества и недостатки полиморфизма
"+"
- Позволяет клиенту не делать предположений об объектах, кроме того, что они поддерживают определенный интерфейс
  (обработка различных данных не различая вида объекта)
- Позволяет изменять поведение во время исполнения
- Позволяет создать базу, каркас для будущих приложений
######
"-"
- При изменении определенного в базовом классе метода, который не имеет своей собственной реализации в потомке,
  может возникнуть непредсказуемое поведение программы.
- Может уменьшить читаемость кода. Поскольку полиморфизм идёт в ногу с наследованием и сам полиморфный метод,
  объявленный в базовом и/или родительском классе, может иметь разную реализацию — значит определение и ориентирование среди
  всей иерархии классов становится затруднительным, особенно когда требуется определить реализацию в определенный
  момент времени, что в свою очередь, в некоторой степени, может увеличить время работы разработчика.
  
Важно. По сути, это не "прямые" недостатки полиморфизма, а, своего рода, отражения (влияния) недостатков наследования.

### Преимущества и недостатки наследования
"+"
- Переиспользование кода (и производные: компоненты, программы, макеты/прототипы)
- Связанность объектов
- Согласованность интерфейсов
- Сокрытие данных 
- Полиморфизм 
######
"-"
- Связанность объектов
- Может уменьшить читаемость кода. Поскольку полиморфизм идёт в ногу с наследованием и сам полиморфный метод,
  объявленный в базовом и/или родительском классе, может иметь разную реализацию — значит определение и ориентирование среди
  всей иерархии классов становится затруднительным, особенно когда требуется определить реализацию в определенный
  момент времени, что в свою очередь, в некоторой степени, может увеличить время работы разработчика.
- Усложнение кода. Модификация родительского класса может повлиять на поведение классов потомков, и если поведение потомка
  логически не может быть согласованным в соответствии с новым методом, то приходиться либо менять структуру иерархии классов,
  либо нарушать принцип подстановки Барабары Лисков.
### Как заменить наследование
[Композицией.](https://coderlessons.com/articles/programmirovanie/zamena-nasledovaniia-kompozitsiei)
Суть заключается в том, что создаётся отдельный класс, в котором новое поле (свойство) является объектом нужного класса
и определяется путем передачи данного класса в соответствующий метод извне.

По сути это также может быть и реализация паттерна Делегирование, что в свою очередь является своего рода реализацией паттерна Стратегия.
[Подробнее](https://refactoring.guru/ru/replace-inheritance-with-delegation) 
### SOLID

### GRASP
**G**eneral **R**esponsibility **A**ssignment **S**oftware **P**atterns

Это паттерны проектирования, используемые в ООП для решения общих задач по назначению обязанностей классам и объектам.</br>
Или проще - шаблоны распределения обязанностей.

Однако стоит понимать, что хоть в названии и встречается слово **Patterns** - это не значит что речь пойдёт
целиком и полностью о паттернах (шаблонах) проектирования, а больше о, своего рода, принципах распределения ответственности.</br>
В состав **GRASP** включается 9 таких _**принципов-шаблонов**_:</br>
###### основные:
- **Information Expert** (Информационный эксперт)
- **Creator** (Создатель)
- **Controller** (Контроллер)
- **Low Coupling** (Низкая связанность)
- **High Cohesion** (Высокая сцепленность)
###### дополнительные:
- **Pure Fabrication** (Чистое производство или Чистая выдумка)
- **Indirection** (Посредник)
- **Polymorphism** (Полиморфизм)
- **Protected Variations** (Сокрытие реализации)

##### Information Expert
Информационный  эксперт. Как можно предположить из названия - это должен быть объект, который обладает нужной информацией.</br>
Рассмотрим на примере Форума и получении информации о количестве комментариев к определенному посту и итоговом количестве комментариев для конкретной категории.</br>
Допустим имеем такую структуру: `Forum->Category->Post->Comment`</br>
В нашем конкретном случае для определения информационного экусперта нам необходимо ответить на вопросы:
- Кто должен знать количество комментариев к посту?
- Кто должен знать количество комментариев всех постов категории?

Когда мы определяем все данные для страницы с постами темы (категории) форума, а именно список постов -
то логично использовать сущность категории и для определения количества постов данной категории. Этот же принцип мы можем использовать
и для получения количества комментариев к каждому такому посту. А это значит, что общее количество комминтов ко всем постам категории
необходимо получить непосредственно благодаря объекту (классу) Category.</br>
Рассмотрим другой пример:</br>
Имеем систему классов: Customer (покупатель/клиент), Order (заказ), содержащий список OrderItemList (строчек заказа),
элементы которого в свою очередь содержат Product (товар) и его количество, а товар может содержать, например, цену, название и т.д.</br>
Теперь нам необходимо просчитать сумму заказа. Возвращаясь к вопросам, описанным выше - кто как не клиент работает с заказами?
Следовательно, получить сумму товаров можно написав простой метод в клиентском коде (классе), работающим с заказом,
в котором циклом проходим по всем строчкам заказа и суммируем цену товаров.</br>
Казалось бы всё очевидно. Проанализируем кейс. Бизнес-логика для определения итоговой суммы заказа определена в клиентсом коде
и может там же модифицироваться в будущем, допустим различными скидками, купонами, оптовыми ценами и пр...
Насколько разумно будет добавлять массу IF-ов в это метод, поддерживать его, при этом править непосредственно клиентский клас.
Появляется дополнительная зависимость класа Customer от других сущностей. А если нам потребуются эти вычисления для
в другом месте (склад, доставка, ежемесячные отчёты) ?</br>
Отвечая на эти вопросы приходим к выводу, что логичнее разместить метод определения стоимости непосредственно в классе,
отвечающем за сам заказ. Клиентский код теперь будет зависет только на сущности Order и не будет иметь понятия о том, как именно происходят вычисления.</br>
По итогу получаем, что тот, кто обладает максимальным количеством информации - и должен выступать в роли информационного эксперта.</br>
Таким образом мы соблюдаем базовый принцип распределенности ответственности: _**Ответственность должна быть назначена тому,
кто владеет максимумом необходимой информации для исполнения — информационному эксперту.**_</br>

##### Creator
##### Controller
##### Low Coupling
##### High Cohesion



### DI Container

### Агрегация VS композиция

### Паттерны

### Singleton - это антипаттерн. Причина. Как решить на примере: “Singleton реализует соединение с прод БД. Как произвести тестирование с тестовой БД?”

### По ТЗ (гит):
- review
- какие паттерны используются
- преимущества и недостатки switch case, чем заменить
- нужно ли менять try catch и по какой причине

### Задача

Есть файл на неопределенное количество строк. В каждой строке информации на 10 - 1024 кБ.
Необходимо реализовать функционал для переноса уникальных строк в БД.
Со временем количество файлов может увеличиться. Уникальность строк в рамках разных файлов не гарантируется (тоесть строка в одном файле может дублироваться и в другом файле)

Описать алгоритм и ключевые моменты реализации функционала.
