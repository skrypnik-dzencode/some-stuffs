# Знакомство с Git

## Предисловие, история проблемы

После мучительной работы с обычным копированием файлов многие столкнулись с тем, что командная разработка становится тем сложнее, чем больше людей в ней участвует. Больше всего проблем возникает, когда люди работают над одними и теми же файлами.

Иллюстрация из перевода статьи разработчика Warcraft Патрика Вайата:

> "...когда я начал активно работать с другими художниками и разработчиками, мы обычно использовали «пешеходную локалку», то есть по сути носили друг другу из офиса в офис флоппи-диски с изменениями, которые необходимо было внедрить в код или в дизайн.

> Боб Фитч был вторым разработчиком на проекте и мы с ним постоянно копировали файлы и изменения в коде между собой. Периодически мы ошибались при интеграции и баги, которые мы уже фиксили, открывались заново. Мы вылавливали их снова и обнаруживали, что когда копировали файлы, вносили изменения — мы перезаписывали что-то поверх удачных баг-фиксов, и порой приходилось вспоминать как мы уже закрывали эти баги заново.

> И эта ситуация повторялось всё чаще и чаще, ведь мы ускорялись в разработке, а никакого другого процесса для контроля версий, помимо метода «запоминание где и что мы редактировали» у нас не было. Мне в какой-то степени повезло больше, ведь мой компьютер хранил «мастер» ветку нашего кода, куда мы добавляли патчи, поэтому мои изменения в коде терялись реже. Сегодня для этого мы используем системы контроля версий, но тогда мы даже не могли вообразить себе такие радости жизни!"

[первая часть статьи](http://geektimes.ru/post/149298/)

[вторая часть статьи](https://geektimes.ru/post/149974/)

![](https://raw.githubusercontent.com/skrypnik-dzencode/some-stuffs/master/images/git/tel-me-about-coding-without-vcs.jpg)

**Итак, основная проблема - перезаписывание неактуального кода поверх актуального, потеря актуального кода.**

Были предприняты попытки контролировать человеческий фактор, распределять файлы между разработчиками, но это все только осложнило. 

## Основы: команда diff

Уже в 1974 году существовала юниксовая команда diff.

Ниже приведен пример простого текста.

```
1qweqwe
2erfevef
3efvercer
4vfvrvtr
6dvdfvdfv
```

В следующем листинге тот же самый текст немного изменен с целью демонстрации программы diff.

```
1qweqwe
3efvercer
4vfvrvtr
5owiceowcno
6dvdfvdfv
```

Имея два практически идентичных файла, можно при помощи команды diff с ключами -uN понять, какая между ними разница:

**`diff -uN test.txt test1.txt:`**

```diff
--- test.txt	2019-03-04 16:34:31.000000000 +0200
+++ test1.txt	2019-03-04 16:34:57.000000000 +0200
@@ -1,5 +1,5 @@
 1qweqwe
-2erfevef
 3efvercer
 4vfvrvtr
+5owiceowcno
 6dvdfvdfv
```

Команда diff работает для двух разных файлов. Система контроля версий отслеживает изменения в одном и том же файле разных версий.

## Системы Контроля Версий (СКВ)

Затем стали задумываться над тем, чтобы ограничить все возникающие сложности и управлять проблемами при помощи кода и автоматизации, стали изобретать различные программы для этих целей. 

Программы, которые позволяют сохранять различные файлы и различные версии этих файлов, сравнивать файлы и различные их версии, иметь возможность переходить между различными версиями файлов, называются **Системами контроля версий**
(Version Control System - VCS).

### Виды систем контроля версий

Первая, простейшая СКВ - это просто **резервное копирование файлов**.

![](https://git-scm.com/book/en/v2/images/local.png)

Можно сохранять все в файл, или записывать в БД инфу о файлах и их версиях, но суть не меняется - все хранится **на локальном** компьютере.

Второй, более продвинутый вариант - **централизованная СКВ**. Суть такого подхода - хранение кода на сервере и использование на локальных машинах.

![](https://git-scm.com/book/en/v2/images/centralized.png)

![](https://raw.githubusercontent.com/skrypnik-dzencode/some-stuffs/master/images/git/no-vcs-depression-mem.jpg)

На данный момент "последним писком моды" в данном вопросе является **распределенная СКВ**.

![](https://git-scm.com/book/en/v2/images/distributed.png)

Изменения делаются на локальных машинах, версии же сохраняются и на них, и на сервере.

Вот этот парень - Линус Торвальдс. 

![](https://raw.githubusercontent.com/skrypnik-dzencode/some-stuffs/master/images/git/linus-fk.jpg)

Он когда-то и придумал GIT.


### Основные термины и понятия при работе с системой Git
    Репозиторий —
дерево изменений проекта.После создания нового репозитория дерево содержит только одну ветку — master. Ветка состоит из коммитов, расположенных в хронологическом порядке. Как правило, в ветке master находятся проверенные и протестированные изменения.

    Ветка — 
указатель на коммит.  На один коммит может указывать несколько веток. Как правило это случается при создании новой ветки из текущей. Например для реализации в ней новой задачи. По мере добавления коммитов — ветки будут расходится в разные стороны.
    
    Коммит (от слова commit - фиксировать) — 
логическая единица изменений.Каждый из них имеет историю уникальный ID и цепочку предшествующих коммитов. Можно «откатить» (отменить) изменения любого из коммитов. Для любого коммита из истории можно создать указатель, то есть ветку. 
    
    Индекс — 
изменения, которые будут зафиксированы при следующем коммите.При этом, во время коммита, могут быть изменения, не добавленные в индекс — они не будут закоммичены. Их надо будет отдельно добавить в индекс и зафиксировать. Таким образом, можно вносить разом, все необходимые по мере работы, правки и фиксировать их логическими группами.

### Основные команды 

**init** — создает новый репозиторий

**status** — отображает список измененных, добавленных и удаленных файлов

**branch** — отображает список веток и активную среди них

**add** — добавляет указанные файлы в индекс

**reset** — удаляет указанные файлы из индекса

**commit** — фиксирует добавленнные в индекс изменения

**checkout** — переключает активную ветку; отменяет не добавленные в индекс изменения

**merge** — объединяет указанную ветку с активной

**log** — выводит список последних коммитов (можно указать количество и формат)

### Примеры команд для работы с гитом

Создайте новую папку для тестового проекта. 
Чтобы начать работу с гитом, надо его инициализировать — открыть консоль, перейти в корневую папку проекта и выполнить команду:

**`git init`**

Эта команда создаст новый пустой репозиторий. Проще говоря, появится папка .git с какими-то непонятными файлами. Причем такой репозиторий, который находится в папке проекта, файлы которого вы можете менять — называется «рабочей копией». Существуют еще «внешние копии» или bare-репозитории.

Все остальные команды можно вызывать в корневой папке или в одной из вложенных.

Теперь можно вносить изменения.

Список изменений можно увидеть выполнив команду:

**`git status`**

В консоли появится список измененных файлов.

Добавьте файлы, изменения в которых вы хотите зафиксировать:

**`git add file_name_a.php`**

Файлы можно указывать через пробел. Все файлы в данной папке и ее подпаках можно добавить командой:

**`git add .`**

Будьте внимательны, эта команда не добавит новые файлы в индекс. Добавятся только модифицированные старые файлы и удаленные. Новые файлы можно добавить явно указав имя.

Добавить все новые и измененные файлы можно командой:

**`git add -A`**

Изменения стоит фиксировать логическими блоками, то есть в одном коммите должны быть файлы связанные с решением одной конкретной ошибки или одной конкретной новой задачи.

Если вы добавили файл из другого логического блока, удалите его из индекса командой:

**`git reset file_name_b.php`**

Зафиксируйте эти изменения в другом коммите. Так будет удобнее при просмотре истории изменений и отмене изменений.

Если вы случайно изменили не тот файл - верните его к последнему зафиксированному состоянию командой:

**`git checkout file_name_c.php`**

Отменить изменения всех, ранее существующих, файлах в данной и вложенных папках можно командой:

**`git checkout -- .`**

Ненужные новые файлы достаточно просто удалить. Или это можно сделать командой:

**`git reset --hard HEAD`**

Проект будет полностью приведен к последнему зафиксированному состоянию.

**`git commit`**

Откроется текстовый редактор по-умолчанию для того, чтобы добавить комментарий к коммиту. Распишите, что и зачем вы меняли. Но не перечисляйте список измененных файлов — гит сделает это за вас. Комментарий должен коротким и понятным, например:

    fix| order price
    now price includes vat

Комментарии лучше писать на английском языке, в первую очередь потому, консоль может не поддерживать кириллицу и вместо описания будут кракозяблики.

Первая строка самая важная и должна включать суть коммита в нескольких словах. Дальше можете не жалеть строк и расписать подробно что, зачем и почему было изменено (речь про логику, а не про файлы).

Теперь можно посмотреть историю изменений, ваш коммит должен в ней отобразиться:

**`git log`**

### Заключение
Как видите, ничего сложного.

Конечно, это далеко не все, что может гит, но именно этого мне не хватало в свое время для того, чтобы начать пользоваться системой контроля версий.

## Статусы файлов, команды status, add, commit, config, log

В локальном репозитории, как и в любой обычной папке, могут находиться файлы и папки. Отличие локального репозитория от обычной папки на вашем жестком диске в том, что за изменениями файлов и папок следит система контроля версий. Файлы могут быть неотслеживаемыми т.е. теми, которые не находятся под контролем версий, отслеживаемыми, измененными и подготовленными к коммиту. Рассмотрим эти состояния поподробнее:

![](https://raw.githubusercontent.com/skrypnik-dzencode/some-stuffs/master/images/git/lifecycle.png)

- **Неотслеживаемый (untracked)** - изначально файлы и папки в локальном репозитории являются неотслеживаемыми. Если файл хоть один раз добавлялся под контроль версий, он уже отслеживаемый.
- **Отслеживаемый (tracked)** - файл уже под контролем версий git, но со времени последнего сохранения в него не вносились изменения.
- **Измененный (modified)** - файл под контролем версий и в нем есть несохраненные изменения, которые пока не проиндексированы.
- **Проиндексированный или подготовленный к коммиту (staged)** - в файле есть изменения, которые проиндексированы и будут сохранены в ближайшем коммите.

Понятие индексирования довольно простое. Есть некий **индекс (index, stage),** который является набором изменений в файлах. Это те изменения, которые находятся под контролем версий, и которые программист запланировал сохранить в самом ближайшем сохранении - коммите. 

## Работа с удаленным репозиторием, ssh, ключи

Есть два пути для общения (дружбы) репозитория удаленного (глобальное хранилище, такое как **`github`** или **`gitlab`**) и локального (читай, ваших файлов, с которыми работает разработчик будь то локально или на удалённом сервере). Собственно пути: `https` и `ssh`. `HTTPS` - довольно простой путь, однако может требовать постоянной аутентификации по логину и паролю. Лично я, ну и многие могут со мной согласиться, предпочитаю (да и вам советую) более сложный и интересный путь `SSH`.

И вот для такого взаимодействия следует ознакомится и взять на вооружение [Мануал по созданию rsa ключей](https://git-scm.com/book/ru/v2/Git-%D0%BD%D0%B0-%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80%D0%B5-%D0%93%D0%B5%D0%BD%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D1%8F-%D0%BE%D1%82%D0%BA%D1%80%D1%8B%D1%82%D0%BE%D0%B3%D0%BE-SSH-%D0%BA%D0%BB%D1%8E%D1%87%D0%B0)


# Полезные ссылки

[Онлайн книга про Git](https://git-scm.com/book/ru/v1)

[Git Branching (interactive game)](http://learngitbranching.js.org/)

[Git game или в поисках Линуса Торвальдса)](https://habr.com/ru/post/250025/)

[Git practice with visualisation](http://git-school.github.io/visualizing-git/)

[Git cheatsheet](https://github.github.com/training-kit/downloads/ru/github-git-cheat-sheet/)

[Git cheatsheet with visualisation](https://ndpsoftware.com/git-cheatsheet.html)

[Udemy курс по гиту](https://www.udemy.com/course/version-control-with-git-step-by-step-tutorial-3-in-1/)

[Подробнее обо всех командах git](https://git-scm.com/docs)

[Еще больше о погружении в git](https://gitimmersion.com/)

[Быстрый старт с GIT](http://habrahabr.ru/post/125799/)
